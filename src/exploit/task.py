from typing import *
from uuid import uuid4

from exploit.variable import Variable
from exploit.instruction import Instruction, Assign, Operator, Read, Constant

class Task:
    """A 'task' will consist of only simple instructions like :

        x = 10
        y = x
        z = x + y
        w = z - 10
        w = w / 10
        z = z * 10
    
    Here is an exemple of how to write instructions for a task :

        t = Task(instructions=[
            Assign('x', 10),
            Assign('y', 22),
            Add('x', 'y', 'z'),
            Sub('z', 40, 'z')
        ])
    """
    ID = 1
    Tasks = []

    def __init__(self,
        instructions:List[Instruction] = [],
        dependencies:Iterable['Task']=[],
        name:Optional[Union[str, int]]=None
    ):
        # Ensure each name is different
        name = name if name else self.__class__.ID
        try:
            existing = next(x.name for x in self.__class__.Tasks if x.name == name)
            raise ValueError('{} already exists.'.format(repr(existing)))
        except StopIteration:
            pass

        self.name = name
        self.instructions = instructions
        self.dependencies = set(dependencies)
        self.children = None

        self.read_domain = self.__get_read_domain()
        self.write_domain = self.__get_write_domain()

        self.__class__.ID += 1
        self.__class__.Tasks.append(self)

    def __repr__(self) -> str:
        return '<Task(name={})>'.format(self.name)
    
    def __hash__(self) -> int:
        return hash(self.name)

    def __eq__(self, o:Any) -> bool:
        if not isinstance(o, Task):
            return False
        return self.name == o.name

    def __lt__(self, o:Any) -> bool:
        if not isinstance(o, Task):
            return False

        if self.is_connected(o):
            return False
        elif o.is_connected(self):
            return True
        else:
            return self.name < o.name

    def __call__(self):
        """Execute the instructions sequentially."""

        for i in self.instructions:
            i()
            
    def get_memory_cells(self) -> Set[Variable]:
        """Returns every memory cells used by the task.

        Returns:
            Set[Variable]: The union of the read and write domains.
        """
        return self.write_domain.union(self.read_domain)

    def __get_read_domain(self) -> Set[Variable]:
        """Get the read domain recursively."""

        def recurse(i:Instruction) -> Set[Variable]:
            result = set()

            if isinstance(i, Read):
                result.add(i.variable)
            elif isinstance(i, Operator):
                result = result.union(recurse(i.i1), recurse(i.i2))

            return result

        ####################
        result = set()

        for i in self.instructions:
            result = result.union(recurse(i))
        
        return result

    def __get_write_domain(self) -> Set[Variable]:
        """Get the write domain recursively."""

        def recurse(i:Instruction) -> Set[Variable]:
            result = set()

            if isinstance(i, Assign):
                result.add(i.variable)
            elif isinstance(i, Operator) and i.variable:
                result.add(i.variable)

            return result

        ####################
        result = set()

        for i in self.instructions:
            result = result.union(recurse(i))
        
        return result

    def is_connected(self, task:'Task') -> bool:
        """Determines if the current task is connected to the supplied one.

        T(searched) ---- T(0) ----> T(1) ----> ... ----> T(k) ----> T(current)

        Args:
            task (Task): The searched task.

        Returns:
            bool: Indicates if it is connected.
        """
        def recurse(search_task:'Task', current_task:'Task') -> bool:
            if search_task in current_task.dependencies:
                return True

            for dependency in current_task.dependencies:
                if recurse(search_task, dependency):
                    return True
            
            return False

        return recurse(task, self)
    
    def is_interfering(self, task:'Task') -> bool:
        """Returns a boolean, indicating if the task is interfering with the supplied one.

        Args:
            task (Task): The task to be tested on.

        Returns:
            bool: Indicates if it interferes.
        """
        conditions = [
            not self.read_domain.intersection(task.write_domain) \
            and not task.read_domain.intersection(self.write_domain) \
            and not self.write_domain.intersection(task.write_domain),

            self.is_connected(task) or task.is_connected(self)
        ]

        return not (conditions[0] or conditions[1])