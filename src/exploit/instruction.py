from typing import *
from exploit.variable import Variable
import operator

class Instruction:
    def __init__(self, *args, **kwargs):
        """Every arguments such as instances of Variable, etc...

        Raises:
            NotImplementedError: Shall be overwritten.
        """
        raise NotImplementedError()

    def __call__(*args, **kwargs) -> int:
        """Execute the instructions recursively.

        Raises:
            NotImplementedError: Shall be overwritten.

        Returns:
            int: The value of the instruction.
        """
        raise NotImplementedError()

class Constant(Instruction):
    """Represents a simple integer as an Instruction.
    """
    def __init__(self, value:int):
        self.value = value

    def __call__(self) -> int:
        return self.value

class Read(Instruction):
    def __init__(self, variable:Variable):
        self.variable = variable
    
    def __call__(self) -> int:
        return int(self.variable)

class Assign(Instruction):
    def __init__(self, variable:Variable, instruction:Union[Variable, Instruction, int]):
        self.variable = variable

        if isinstance(instruction, Variable):
            instruction = Read(Variable)
        elif isinstance(instruction, int):
            instruction = Constant(instruction)
        self.instruction = instruction

    def __call__(self) -> Variable:
        self.variable(self.instruction())
        return self.variable

########################################
# Operators
########################################
class Operator(Instruction):
    def __init__(self, i1:[Variable, Instruction, int], i2:[Variable, Instruction, int], variable:Optional[Variable]=None):
        """Initialize basic operations like +, -, /, *.

        Args:
            i1 (Variable, Instruction, int]): First "instruction". May be converted, depending of its type.
            i2 (Variable, Instruction, int]): Second "instruction". May be converted, depending of its type.
            variable (Optional[Variable], optional): The variable where the result will be stored in. If no one is provided, only the result will be returned in __call__(). Otherwise, the variable will be returned.
        """
        self.variable = variable
        self.i1 = self.convert(i1)
        self.i2 = self.convert(i2)

    def __call__(self, op:Callable[[Any, Any], Any]) -> Union[Variable, int]:
        value = op(self.i1(), self.i2())
        if not self.variable:
            return value

        self.variable(value)
        return self.variable

    def convert(self, instruction:Union[Variable, Instruction, int]) -> Instruction:
        if isinstance(instruction, Variable):
            instruction = Read(instruction)
        elif isinstance(instruction, int):
            instruction = Constant(instruction)
        return instruction

class Add(Operator):
    def __call__(self) -> Union[Variable, int]:
        super().__call__(op=operator.add)

class Sub(Operator):
    def __call__(self) -> Union[Variable, int]:
        super().__call__(op=operator.sub)

class Mul(Operator):
    def __call__(self) -> Union[Variable, int]:
        super().__call__(op=operator.mul)

class Div(Operator):
    def __call__(self) -> Union[Variable, int]:
        # We're dealing with integers
        # so only floored divisions for the moment
        super().__call__(op=operator.floordiv)