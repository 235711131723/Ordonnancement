from typing import *
import operator

from exploit.variable import Variable

class Instruction:
    """A prototype class used to forge simple instructions like +, -, *, /, = (assigning).
    
    If the instruction belongs to these types : {str, int, Variable},
    then it gets converted to an instance of Instruction.

    Respectfully, x being the given command :
        - str => Read(Variable(x))
        - int => Constant(x)
        - Variable => Read(x)
    """

    def __init__(self, *args, **kwargs):
        """Every arguments such as instances of Variable, etc...

        Raises:
            NotImplementedError: Shall be overwritten.
        """
        raise NotImplementedError()

    def __call__(*args, **kwargs) -> int:
        """Execute the instructions recursively.

        Raises:
            NotImplementedError: Shall be overwritten.

        Returns:
            int: The value of the instruction.
        """
        raise NotImplementedError()

class Constant(Instruction):
    """Represents a simple integer as an Instruction.
    """
    def __init__(self, value:int):
        self.value = value

    def __call__(self) -> int:
        return self.value

class Read(Instruction):
    def __init__(self, variable:Variable):
        self.variable = variable
    
    def __call__(self) -> int:
        return int(self.variable)

class Assign(Instruction):
    """Implements the assigning operation.
    
    This class can be used in the following ways :
    
        Assign(Variable['x'], 10)
        Assign('x', 10)

        Assign('y', 20)
        Assign('x', 'y')

    Suppose the second variable has already been initialized (= contains a value).
    These are equivalent :

        Assign('x', Variable['y'])
        Assign(Variable['x'], 'y')
        Assign(Variable['x'], Variable['y'])
    """

    def __init__(self, variable:Union[Variable, str], instruction:Union[Variable, Instruction, str, int]):
        if isinstance(variable, str):
            variable = Variable[variable]
        self.variable = variable

        if isinstance(instruction, Variable):
            instruction = Read(variable)
        elif isinstance(instruction, str):
            instruction = Read(Variable(instruction))
        elif isinstance(instruction, int):
            instruction = Constant(instruction)
        self.instruction = instruction

    def __call__(self) -> Variable:
        value = self.instruction()
        self.variable(value)
        self.variable.history.append(value)
        return self.variable

########################################
# Operators
########################################
class Operator(Instruction):
    def __init__(self, i1:Union[Variable, Instruction, str, int], i2:Union[Variable, Instruction, str, int], variable:Optional[Union[Variable, str]]=None):
        """Initialize a prototype type later used for basic operations like +, -, /, *.

        Args:
            i1 (Variable, Instruction, int]): First "instruction". May be converted, depending of its type.
            i2 (Variable, Instruction, int]): Second "instruction". May be converted, depending of its type.
            variable (Optional[Variable], optional): The variable where the result will be stored in. If no one is provided, only the result will be returned in __call__(). Otherwise, the variable will be returned.
        """
        if isinstance(variable, str):
            variable = Variable[variable]
        self.variable = variable
        self.i1 = self.__convert(i1)
        self.i2 = self.__convert(i2)

    def __call__(self, op:Callable[[Any, Any], Any]) -> Union[Variable, int]:
        value = op(self.i1(), self.i2())
        if not self.variable:
            return value

        self.variable(value)
        return self.variable

    def __convert(self, instruction:Union[Variable, Instruction, str, int]) -> Instruction:
        if isinstance(instruction, Variable):
            instruction = Read(instruction)
        elif isinstance(instruction, str):
            instruction = Read(Variable[instruction])
        elif isinstance(instruction, int):
            instruction = Constant(instruction)
        return instruction

class Add(Operator):
    def __call__(self) -> Union[Variable, int]:
        super().__call__(op=operator.add)

class Sub(Operator):
    def __call__(self) -> Union[Variable, int]:
        super().__call__(op=operator.sub)

class Mul(Operator):
    def __call__(self) -> Union[Variable, int]:
        super().__call__(op=operator.mul)

class Div(Operator):
    def __call__(self) -> Union[Variable, int]:
        # We're dealing with integers
        # so only floored divisions for the moment
        super().__call__(op=operator.floordiv)