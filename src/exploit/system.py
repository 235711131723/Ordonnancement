from typing import *
from rich.pretty import pprint
import bs4
import copy
import itertools
import graphviz
import threading
import toposort

from exploit.task import Task
from exploit.variable import Variable

class System:
    """A class to implement a system of tasks.
    It MUST be determistic.
    """

    def __init__(self, tasks:List[Task]):
        self.tasks = copy.deepcopy(tasks)
        
        if not self.is_deterministic():
            raise RuntimeError('Le système n\'est pas déterminé.')

    ########################################
    # Tasks
    ########################################
    def get_memory_cells(self) -> Set[Variable]:
        """Get variables used by every tasks.

        Returns:
            Set[Variable]: A set of every used variable.
        """
        cells = set()

        for task in self.tasks:
            cells = cells.union(task.get_memory_cells())
        
        return cells

    def get_history_of_values(self, variable:Union[Variable, str]) -> List[Optional[int]]:
        """Get the history of values of a variable.

        Args:
            variable (Variable): The studied variable.

        Returns:
            List[Optional[int]]: The list of the values of the variable after each instruction.
        """
        if isinstance(variable, str):
            variable = Variable[variable]

        return variable.history

    ########################################
    # System-related methods
    ########################################
    def is_equivalent(self, system:'System') -> bool:
        """Determines if these systems are equivalent.

        Args:
            system (System): The system to compare to.

        Returns:
            bool: A boolean indicating their equivalency.
        """
        raise NotImplementedError()

    def is_deterministic(self) -> bool:
        """Determines if the system is deterministic.

        Returns:
            bool: The system is determinstic if each pair of two tasks t1, t2 from the system are not interfering with each other.
        """
        for t1, t2 in itertools.combinations(self.tasks, r=2):
            if t1.is_interfering(t2):
                return False

        return True
    
    ########################################
    # Drawing graphs
    ########################################
    def __generate_label(self, task:Task) -> str:
        soup = bs4.BeautifulSoup('', 'html.parser')

        table = soup.new_tag('TABLE')

        # Title
        tr = soup.new_tag('TR')
        td = soup.new_tag('TD')
        td['BGCOLOR'] = 'cyan'

        title = soup.new_tag('B')
        title.string = str(task.name)

        td.append(title)
        tr.append(td)
        table.append(tr)

        # Instructions
        for instruction in task.instructions:
            tr = soup.new_tag('TR')
            td = soup.new_tag('TD')
            td.string = str(instruction)
            tr.append(td)
            table.append(tr)

        soup.append(table)
        return str(soup)

    def draw(self, output:Optional[str]=None, view:bool=False):
        dot = graphviz.Digraph(comment='Graph')
        for layer in self.get_layers():
            for task in layer:
                dot.node(
                    name=str(task.name),
                    label='<{}>'.format(self.__generate_label(task))
                )
                for parent in task.dependencies:
                    dot.edge(tail_name=str(parent.name), head_name=str(task.name))

        dot.render((output if output else 'output') + '.gv', view=view)

    ########################################
    # Tasks
    ########################################
    def get_initial_tasks(self) -> Set[Task]:
        """Get tasks at the most top-level."""
        return set(task for task in self.tasks if not task.dependencies)

    def get_final_tasks(self) -> Set[Task]:
        """Get tasks at the most bottom-level."""
        tasks = []
        for task in self.tasks:
            for t in self.tasks:
                if task in t.dependencies:
                    break
            else:
                tasks.append(task)
        return tasks
    
    def get_closest_common_ancestors(self, tasks:List[Task]) -> List[Task]:
        """Get the common ancestors from two parallel tasks.

        Args:
            tasks (List[Task]): Parallel tasks.

        Returns:
            List[Task]: The list of ancestors.
        """
        ancestors = set()
        for task in tasks:
            if not ancestors:
                ancestors = set(dfs(task, lambda t: t.dependencies))
            else:
                ancestors = ancestors.intersection(dfs(task, lambda t: t.dependencies))
        ancestors = ancestors.difference(tasks)
        return list(ancestors)

    def get_layers(self):
        levels = []

        explored = set()
        level = self.get_final_tasks()
        while level:
            levels.insert(0, level)
            children = set()
            for task in level:
                children = children.union(task.dependencies)
            level = children.difference(explored)
            explored = explored.union(children)
        
        return levels

    ########################################
    # Run
    ########################################
    def reset_memory_cells(self):
        for cell in self.get_memory_cells():
            cell.value = None

    def run(self):
        def execute_tasks_parallel(tasks):
            threads = []
            for task in tasks:
                thread = threading.Thread(target=task)
                threads.append(thread)
                # Appel récursif pour les tâches dépendantes
                execute_tasks_parallel(task.dependencies)  
            for thread in threads:
                thread.start()
            for thread in threads:
                thread.join()
        execute_tasks_parallel(self.get_final_tasks())

class Sequential(System):
    def __init__(self, tasks:List[Task]):
        super().__init__(tasks=tasks)

        graph = {task: task.dependencies for task in self.tasks}
        flatten = toposort.toposort_flatten(graph)
        for i in range(0, len(flatten) - 1):
            flatten[i+1].dependencies = flatten[i]
        
        self.tasks = flatten
    
    def run(self):
        self.reset_memory_cells()

        for task in self.tasks:
            task()

class Parallelize(System):
    def __init__(self, tasks:List[Task]):
        super().__init__(tasks=tasks)

        # Adding arcs everywhere
        for t1, t2 in ((x, y) for x, y in itertools.product(self.tasks, repeat=2) if x.is_connected(y)):
            t1.dependencies.add(t2)

        # Attempting to remove arcs
        # in a way the system remains deterministic
        for t1, t2 in ((x, y) for x, y in itertools.product(self.tasks, repeat=2) if x.is_connected(y)):
            t1.dependencies.remove(t2)

            if not self.is_deterministic():
                t1.dependencies.add(t2)