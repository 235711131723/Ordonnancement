from typing import *
from rich.pretty import pprint
import copy
import itertools
import graphviz
import threading
import toposort

from exploit.task import Task
from exploit.variable import Variable

class ForkingTask(threading.Thread):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

class System:
    """A class to implement a system of tasks.
    It MUST be determistic.
    """

    def __init__(self, tasks:List[Task]):
        self.tasks = tasks
        
        if not self.is_deterministic():
            raise RuntimeError('Le système n\'est pas déterminé.')

    @classmethod
    def sequentialize(cls, tasks:List[Task]):
        graph = {task: task.dependencies for task in tasks}
        flatten = toposort.toposort_flatten(graph)
        for i in range(0, len(flatten) - 1):
            flatten[i+1].dependencies = flatten[i]
        system = cls(tasks=flatten)

        return system

    @classmethod
    def parallelize(cls, tasks:List[Task]):
        raise NotImplementedError()

    ########################################
    # Tasks
    ########################################
    def get_memory_cells(self) -> Set[Variable]:
        """Get variables used by every tasks.

        Returns:
            Set[Variable]: A set of every used variable.
        """
        cells = set()

        for task in self.tasks:
            cells = cells.union(task.get_memory_cells())
        
        return cells

    def get_history_of_values(self, variable:Union[Variable, str]) -> List[Optional[int]]:
        """Get the history of values of a variable.

        Args:
            variable (Variable): The studied variable.

        Returns:
            List[Optional[int]]: The list of the values of the variable after each instruction.
        """
        if isinstance(variable, str):
            variable = Variable[variable]

        return variable.history

    ########################################
    # System-related methods
    ########################################
    def is_equivalent(self, system:'System') -> bool:
        """Determines if these systems are equivalent.

        Args:
            system (System): The system to compare to.

        Returns:
            bool: A boolean indicating their equivalency.
        """
        raise NotImplementedError()

    def is_deterministic(self) -> bool:
        """Determines if the system is deterministic.

        Returns:
            bool: The system is determinstic if each pair of two tasks t1, t2 from the system are not interfering with each other.
        """
        for t1, t2 in itertools.combinations(self.tasks, r=2):
            if t1.is_interfering(t2):
                return False

        return True
    
    ########################################
    # Drawing graphs
    ########################################
    def draw(self, output:Optional[str]=None, view:bool=False):
        dot = graphviz.Digraph(comment='Graph')
        for layer in self.get_layers():
            for task in layer:
                dot.node(
                    name=str(task.name),
                    label='\n'.join([str(x) for x in [task.name] + task.instructions])
                )
                for parent in task.dependencies:
                    dot.edge(tail_name=str(parent.name), head_name=str(task.name))

        dot.render((output if output else 'output') + '.gv', view=view)

    ########################################
    # Tasks
    ########################################
    def get_initial_tasks(self) -> Set[Task]:
        """Get tasks at the most top-level."""
        return set(task for task in self.tasks if not task.dependencies)

    def get_final_tasks(self) -> Set[Task]:
        """Get tasks at the most bottom-level."""
        tasks = []
        for task in self.tasks:
            for t in self.tasks:
                if task in t.dependencies:
                    break
            else:
                tasks.append(task)
        return tasks

    def get_layers(self):
        levels = []

        explored = set()
        level = self.get_final_tasks()
        while level:
            levels.insert(0, level)
            children = set()
            for task in level:
                children = children.union(task.dependencies)
            level = children.difference(explored)
            explored = explored.union(children)
        
        return levels

    ########################################
    # Run
    ########################################
    def reset_memory_cells(self):
        for cell in self.__get_memory_cells():
            cell.value = None

    def run(self):
        """Just run the system as it is right now."""
        self.reset_memory_cells()

        raise NotImplementedError()