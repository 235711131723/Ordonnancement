from typing import *
import copy
import itertools
import threading

from exploit.task import Task
from exploit.variable import Variable

class System:
    """A class to implement a system of tasks.
    It MUST be determistic.
    """

    def __init__(self, tasks:Set[Task]):
        self.tasks = tasks

        if not self.is_deterministic():
            raise RuntimeError('Le système n\'est pas déterminé.')

    def get_memory_cells(self) -> Set[Variable]:
        """Get variables used by every tasks.

        Returns:
            Set[Variable]: A set of every used variable.
        """
        cells = set()

        for task in self.tasks:
            cells = cells.union(task.get_memory_cells())
        
        return cells

    def get_history_of_values(self, variable:Union[Variable, str]) -> List[Optional[int]]:
        """Get the history of values of a variable.

        Args:
            variable (Variable): The studied variable.

        Returns:
            List[Optional[int]]: The list of the values of the variable after each instruction.
        """
        if isinstance(variable, str):
            variable = Variable[variable]

        return variable.history

    def is_equivalent(self, system:'System') -> bool:
        """Determines if these systems are equivalent.

        Args:
            system (System): The system to compare to.

        Returns:
            bool: A boolean indicating their equivalency.
        """
        raise NotImplementedError()

    def is_deterministic(self) -> bool:
        """Determines if the system is deterministic.

        Returns:
            bool: The system is determinstic if each pair of two tasks t1, t2 from the system are not interfering with each other.
        """
        for t1, t2 in ((x, y) for x, y in itertools.product(self.tasks, repeat=2) if x != y):
            if t1.is_interfering(t2):
                return False

        return True

    ########################################
    # Run tasks
    ########################################
    def reset_memory_cells(self):
        for cell in self.__get_memory_cells():
            cell.value = None

    def run_sequentially(self, task:Task):
        def build_system():
            raise NotImplementedError()

        raise NotImplementedError()

    def run_parallelized(self, task:Task):
        def build_system():
            raise NotImplementedError()

        raise NotImplementedError()

    def run_normally(self, task:Task):
        def build_system():
            raise NotImplementedError()

        raise NotImplementedError()

    def run(self, task:Task, sequential:bool):
        self.reset_memory_cells()

        if sequential:
            self.run_sequentially(task)
        else:
            self.run_parallelized(task)