from typing import *
import copy
import itertools
import threading

from exploit.task import Task
from exploit.variable import Variable

class ForkingTask(threading.Thread):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

class System:
    """A class to implement a system of tasks.
    It MUST be determistic.
    """

    def __init__(self, tasks:List[Task]):
        self.tasks = tasks

        if not self.is_deterministic():
            raise RuntimeError('Le système n\'est pas déterminé.')

    def get_memory_cells(self) -> Set[Variable]:
        """Get variables used by every tasks.

        Returns:
            Set[Variable]: A set of every used variable.
        """
        cells = set()

        for task in self.tasks:
            cells = cells.union(task.get_memory_cells())
        
        return cells

    def get_history_of_values(self, variable:Union[Variable, str]) -> List[Optional[int]]:
        """Get the history of values of a variable.

        Args:
            variable (Variable): The studied variable.

        Returns:
            List[Optional[int]]: The list of the values of the variable after each instruction.
        """
        if isinstance(variable, str):
            variable = Variable[variable]

        return variable.history

    def is_equivalent(self, system:'System') -> bool:
        """Determines if these systems are equivalent.

        Args:
            system (System): The system to compare to.

        Returns:
            bool: A boolean indicating their equivalency.
        """
        raise NotImplementedError()

    def is_deterministic(self) -> bool:
        """Determines if the system is deterministic.

        Returns:
            bool: The system is determinstic if each pair of two tasks t1, t2 from the system are not interfering with each other.
        """
        for t1, t2 in ((x, y) for x, y in itertools.product(self.tasks, repeat=2) if x != y):
            if t1.is_interfering(t2):
                return False

        return True
    
    ########################################
    # Drawing graphs
    ########################################
    def draw(self):
        pass

    ########################################
    # Tasks
    ########################################
    def get_initial_tasks(self) -> Set[Task]:
        """Get tasks at the most top-level."""
        return set(task for task in self.tasks if not task.dependencies)

    def get_children_of_task(self, task:Task) -> Set[Task]:
        """Get the children of a task."""
        return set((x for x in self.tasks if task in x.dependencies))

    def get_children_of_tasks(self, tasks:List[Task]) -> Set[Task]:
        """Get their children."""
        children = set()
        for task in tasks:
            children = children.union(self.get_children_of_task(task))
        return children

    def get_layers(self):
        level = self.get_initial_tasks()
        while level:
            yield level
            level = self.get_children_of_tasks(level)

    ########################################
    # Run
    ########################################
    def reset_memory_cells(self):
        for cell in self.__get_memory_cells():
            cell.value = None

    """
    def get_nodes(self):
        def recurse(level:List[Node]) -> List[Node]:
            nodes.

        return recurse(level=[self.Node(task) for task in self.get_initial_tasks()])
    """

    def run_sequentially(self, task:Task):
        """Build a sequential system from the current one then run it.
        """
        def build_system():
            raise NotImplementedError()

        raise NotImplementedError()

    def run_parallelized(self):
        """Build a maximal parallelized system from the current one then run it.
        """
        def build_system():
            raise NotImplementedError()

        raise NotImplementedError()

    def run_normally(self, task:Task):
        """Just run the system as it is right now.
        """
        def build_system():
            raise NotImplementedError()

        raise NotImplementedError()

    def run(self, task:Task, sequential:bool):
        self.reset_memory_cells()

        if sequential:
            self.run_sequentially(task)
        else:
            self.run_parallelized(task)