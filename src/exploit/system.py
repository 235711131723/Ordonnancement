from typing import *
import copy
import itertools
import graphviz
import threading

from exploit.task import Task
from exploit.variable import Variable

class ForkingTask(threading.Thread):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

class System:
    """A class to implement a system of tasks.
    It MUST be determistic.
    """

    def __init__(self, tasks:List[Task]):
        self.tasks = tasks

        if not self.is_deterministic():
            raise RuntimeError('Le système n\'est pas déterminé.')

    def __remove_dependency(self, task:Task):
        removed_dependencies = set()
        while task.dependencies:
            removed_dependency = task.dependencies.pop()
            removed_dependencies.add(removed_dependency)

            if not self.is_deterministic():
                task.dependencies.add(removed_dependency)
                break

    @classmethod
    def parallelize(cls, tasks:List[Task]):
        tasks = copy.deepcopy(Task.Tasks)
        system = cls(tasks)

        for t1, t2 in ((x, y) for x, y in itertools.product(tasks, repeat=2) if x.is_connected(y)):
            system.__remove_dependency(t1)
            print(t1.dependencies)

    @classmethod
    def sequentialize(cls):
        raise NotImplementedError()

    def get_memory_cells(self) -> Set[Variable]:
        """Get variables used by every tasks.

        Returns:
            Set[Variable]: A set of every used variable.
        """
        cells = set()

        for task in self.tasks:
            cells = cells.union(task.get_memory_cells())
        
        return cells

    def get_history_of_values(self, variable:Union[Variable, str]) -> List[Optional[int]]:
        """Get the history of values of a variable.

        Args:
            variable (Variable): The studied variable.

        Returns:
            List[Optional[int]]: The list of the values of the variable after each instruction.
        """
        if isinstance(variable, str):
            variable = Variable[variable]

        return variable.history

    def is_equivalent(self, system:'System') -> bool:
        """Determines if these systems are equivalent.

        Args:
            system (System): The system to compare to.

        Returns:
            bool: A boolean indicating their equivalency.
        """
        raise NotImplementedError()

    def is_deterministic(self) -> bool:
        """Determines if the system is deterministic.

        Returns:
            bool: The system is determinstic if each pair of two tasks t1, t2 from the system are not interfering with each other.
        """
        for t1, t2 in itertools.combinations(self.tasks, r=2):
            if t1.is_interfering(t2):
                return False

        return True
    
    ########################################
    # Drawing graphs
    ########################################
    def draw(self):
        dot = graphviz.Digraph(comment='Graph')
        for layer in self.get_layers():
            for task in layer:
                dot.node(name=str(task.name), label=str(task.name))
                for parent in task.dependencies:
                    dot.edge(tail_name=str(parent.name), head_name=str(task.name))

        dot.render('graph.gv', view=True)

    ########################################
    # Tasks
    ########################################
    def get_initial_tasks(self) -> Set[Task]:
        """Get tasks at the most top-level."""
        return set(task for task in self.tasks if not task.dependencies)

    def get_children_of_task(self, task:Task) -> Set[Task]:
        """Get the children of a task."""
        return set((x for x in self.tasks if task in x.dependencies))

    def get_children_of_tasks(self, tasks:List[Task]) -> Set[Task]:
        """Get their children."""
        children = set()
        for task in tasks:
            children = children.union(self.get_children_of_task(task))
        return children

    def get_layers(self):
        level = self.get_initial_tasks()
        while level:
            yield level
            level = self.get_children_of_tasks(level)

    ########################################
    # Run
    ########################################
    def reset_memory_cells(self):
        for cell in self.__get_memory_cells():
            cell.value = None

    def run(self):
        """Just run the system as it is right now.
        """
        self.reset_memory_cells()

        raise NotImplementedError()