from typing import *
from uuid import uuid4

class Variable:
    VARIABLES = {}

    def __init__(self, name:str, value:Optional[int]=None):
        self.name = name
        self.value = value

        # Add itself to the list of variables,
        # otherwise overwrite the existing one based on the name.
        self.__class__.VARIABLES[self.name] = self

    def __call__(self, value:int) -> 'Variable':
        self.value = value
        return self

    def __class_getitem__(cls, name:str) -> 'Variable':
        """The variables can now be accessed like this :

            Variable[key]
        
        If it does not exist, it will be created.

        Args:
            name (str): The name of the variable.

        Returns:
            Variable: The searched variable.
        """
        if name not in cls.VARIABLES.keys():
            return cls(name)
        return cls.VARIABLES[name]

    def __repr__(self) -> str:
        return '<Variable({}={})>'.format(self.name, self.value)

    def __int__(self) -> int:
        return int(self.value)

    ##############################
    # Magic methods to simulate classic operations like +, -, /, * betweens two instances of Variable.
    ##############################
    def __add__(self, v:'Variable') -> int:
        return self.value + v.value

    def __sub__(self, v:'Variable') -> int:
        return self.value - v.value

    def __mul__(self, v:'Variable') -> int:
        return self.value * v.value

    def __div__(self, v:'Variable') -> int:
        return self.value / v.value

    ##############################
    # It will be stored in set(), so it is needed to be hashable.
    ##############################
    def __hash__(self) -> int:
        return hash(self.name)